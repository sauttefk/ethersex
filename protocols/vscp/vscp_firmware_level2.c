/* * This file is originally a part of VSCP (Very Simple Control Protocol) * http://www.vscp.org * * Copyright (C) 1995-2011 Ake Hedman, eurosource, <akhe@eurosource.se> * * This software is provided 'as-is', without any express or implied * warranty.  In no event will the authors be held liable for any damages * arising from the use of this software. * * Permission is granted to anyone to use this software for any purpose, * including commercial applications, and to alter it and redistribute it * freely, subject to the following restrictions: * * 1. The origin of this software must not be misrepresented; you must not *    claim that you wrote the original software. If you use this software *    in a product, an acknowledgment in the product documentation would be *    appreciated but is not required. * 2. Altered source versions must be plainly marked as such, and must not be *    misrepresented as being the original software. * 3. This notice may not be removed or altered from any source distribution. * * This is an altered version * (c) 2012 Frank Sautter <ethersix@sautter.com> * * This module defines general functions for a level II low resource module. * Many methods must be implemented by the user application to make a full * implemention. */#include "config.h"#include "vscp_projdefs.h"#include "inttypes.h"#include "vscp_class.h"#include "vscp_type.h"#include "vscp_firmware_level2.h"// Constants// Globals// VSCP Data//static vscpEvent inEvent;// VSCP function flags deterine how the software behaves.//  bit 0: 0 == UDP interfase. 1 == TCP interface.//  bit 1: Set if Autodiscovery of server.//  bit 2: Set if Fallback to hard ip address to UDP//  bit 3: Set if Hard coded IP address.//  bit 4: Set if Probe has been sent//  bit 5://  bit 6: Set if incoming message object is in use.//  bit 7: Set if outgoing transmission is in progress.//  bit 8: Reserved.//  bit 9: Reserved.//  bit 10: Reserved.//  bit 11: Reserved.//  bit 12: Reserved.//  bit 13: Reserved.//  bit 14: Reserved. .//  bit 15: Set if raw ethernet activateduint16_t vscp_function_flags;uint8_t vscp_alarmstatus;  // VSCP Alarm Statusuint8_t vscp_node_state;       // State machine stateuint8_t vscp_node_substate;     // State machine substate// page selectoruint16_t vscp_page_select;//////////////////////////////////////////////////////////////////////////////// vscp_init//voidvscp_init(void){  vscp_function_flags = 0;// if server discovery is enabled start in UDP mode#if defined(VSCP_DISCOVER_SERVER) && defined(VSCP_USE_UDP)  vscp_function_flags |= VSCP_FUNCTION_AUTODISCOVER;#else /* VSCP_DISCOVER_SERVER && VSCP_USE_UDP */#if defined(VSCP_USE_TCP)  vscp_function_flags |= VSCP_FUNCTION_USE_TCP;#endif /* VSCP_USE_TCP */#endif /* VSCP_DISCOVER_SERVER && VSCP_USE_UDP */// Fallback from TCP to UDP if failed to connect to TCP server#if defined(VSCP_TCP_FALLBACK)  vscp_function_flags |= VSCP_FUNCTION_FLAG_FALLBACK;#endif /* VSCP_TCP_FALLBACK */// server IP address is hardcoded. if fallback and discovery is enabled// this address will be used after a failed TCP discovery. if this also fails// UDP will be used.#if defined(VSCP_SERVERIP_HARDCODE_IPADDRD)  vscp_function_flags |= VSCP_FUNCTION_HARDCODED_IPADDR;#endif /* VSCP_SERVERIP_HARDCODE_IPADDRD */#if defined(VSCP_USE_UDP )  vscp_udpinit();#endif /* VSCP_USE_UDP */#if defined(VSCP_ENABLE_BOOTLOADER)  bBootLoadMode = FALSE;      // Not in bootload mode#endif /* VSCP_ENABLE_BOOTLOADER */  vscp_page_select = 0;        // Default page}//////////////////////////////////////////////////////////////////////////////// vscp_sendEvent//int8_t vscp_sendEvent(PVSCPEVENT pEvent){  // Fill in GUID  fillGUID(pEvent);#ifdef VSCP_USE_RAW_ETHERNET  vscp_sendRawPacket(pEvent);#endif /* VSCP_USE_RAW_ETHERNET */#if defined(VSCP_USE_UDP) && defined(VSCP_USE_TCP)  if (vscp_function_flags & VSCP_FUNCTION_USE_TCP)    return vscp_sendTCPEvent(pEvent);  else    return vscp_sendUDPEvent(pEvent);#else /* VSCP_USE_UDP && VSCP_USE_TCP */#ifdef VSCP_USE_TCP  return vscp_sendTCPEvent(pEvent);#endif /* VSCP_USE_TCP */#ifdef VSCP_USE_UDP    return vscp_sendUDPEvent(pEvent);#endif /* VSCP_USE_UDP */#endif /* VSCP_USE_UDP && VSCP_USE_TCP */}//////////////////////////////////////////////////////////////////////////////// vscp_getEvent//int8_t vscp_getEvent(vscpEvent * pEvent){#if defined(VSCP_USE_UDP) && defined(VSCP_USE_TCP)  if (vscp_function_flags & VSCP_FUNCTION_USE_TCP)    return vscp_getTCPEvent(pEvent);  else    return vscp_getUDPEvent(pEvent);#else  /* VSCP_USE_UDP && VSCP_USE_TCP */#ifdef VSCP_USE_TCP  return vscp_getTCPEvent(pEvent);#endif /* VSCP_USE_TCP */#ifdef VSCP_USE_UDP  return vscp_getUDPEvent(pEvent);#endif  /* VSCP_USE_UDP */#endif  /* VSCP_USE_UDP && VSCP_USE_TCP */}//////////////////////////////////////////////////////////////////////////////// vscp_readStdReg//uint8_t vscp_readStdReg(uint32_t reg){  uint8_t rv = 0;  if (reg == VSCP_REG_ALARMSTATUS)  {    rv = vscp_alarmstatus;    vscp_alarmstatus = 0x00; // Reset alarm status  }  else if (reg == VSCP_REG_VSCP_MAJOR_VERSION)    rv = VSCP_MAJOR_VERSION;  else if (reg == VSCP_REG_VSCP_MINOR_VERSION)    rv = VSCP_MINOR_VERSION;  else if (reg == VSCP_REG_NODE_CONTROL)    rv = 0;  else if (reg == VSCP_REG_FIRMWARE_MAJOR_VERSION)    rv = vscp_getFirmwareMajorVersion();  else if (reg == VSCP_REG_FIRMWARE_MINOR_VERSION)    rv = vscp_getFirmwareMinorVersion();  else if (reg == VSCP_REG_FIRMWARE_SUB_MINOR_VERSION)    rv = vscp_getFirmwareSubMinorVersion();  else if (reg >= VSCP_REG_USERID0 &&           reg <= VSCP_REG_USERID4)    rv = vscp_getUserID(reg - VSCP_REG_USERID0);  else if (reg >= VSCP_REG_MANUFACTUR_ID0 &&           reg <= VSCP_REG_MANUFACTUR_SUBID3)    rv = vscp_getManufacturerId(reg - VSCP_REG_MANUFACTUR_ID0);  else if (VSCP_REG_NICKNAME_ID == reg)    rv = 0xFF;                // Always undefined  for Level II  else if (VSCP_REG_PAGE_SELECT_LSB == reg)    rv = (vscp_page_select & 0xFF);  else if (VSCP_REG_PAGE_SELECT_MSB == reg)    rv = (vscp_page_select >> 8) & 0xFF;  else if (VSCP_REG_BOOT_LOADER_ALGORITHM == reg)    rv = VSCP_BOOTLOADER_NONE;  else if (VSCP_REG_BUFFER_SIZE == reg)    rv = vscp_getBufferSize();  else if ((reg >= VSCP_REG_GUID) && (reg <= VSCP_REG_GUID15))    rv = vscp_getGUID(reg - VSCP_REG_GUID);  else if ((reg >= VSCP_REG_DEVICE_URL) &&           (reg <= VSCP_REG_DEVICE_URL + VSCP_SIZE_DEVURL))    rv = vscp_getMDF_URL(reg - VSCP_REG_DEVICE_URL);  return rv;}//////////////////////////////////////////////////////////////////////////////// vscp_writeStdReg//uint8_t vscp_writeStdReg(uint32_t reg, uint8_t data){  uint8_t rv = ~data;  if (reg >= VSCP_REG_USERID0 &&      reg <= VSCP_REG_USERID4)  {    vscp_setUserID((reg - VSCP_REG_USERID0), data);    rv = vscp_getUserID((reg - VSCP_REG_USERID0));  }  else if (VSCP_REG_PAGE_SELECT_MSB == reg)  {    vscp_page_select = (vscp_page_select & 0x00FF) | ((uint16_t) data << 8);    rv = (vscp_page_select >> 8) & 0xFF;  }  else if (VSCP_REG_PAGE_SELECT_LSB == reg)  {    vscp_page_select = (vscp_page_select & 0xFF00) | data;    rv = (vscp_page_select & 0xFF);  }#ifdef ENABLE_WRITE_2PROTECTED_LOCATIONS  else if ((reg >= VSCP_REG_MANUFACTUR_ID0) &&           (reg <= VSCP_REG_MANUFACTUR_SUBID3))  {    /* page must be 0xFFFF for writes to be possible */    if (vscp_page_select == 0xFFFF)    {      vscp_setManufacturerId(reg - VSCP_REG_MANUFACTUR_ID0, data);      rv = vscp_getManufacturerId(reg- VSCP_REG_MANUFACTUR_ID0);    }  }#endif /* ENABLE_WRITE_2PROTECTED_LOCATIONS */}//////////////////////////////////////////////////////////////////////////////// sendServerProbe//#ifdef VSCP_DISCOVER_SERVERvoidsendHighEndServerProbe(void){  uint8_t *data = vscp_createHead(mode, VSCP_CLASS1_PROTOCOL,    VSCP_TYPE_PROTOCOL_HIGH_END_SERVER_PROBE, VSCP_PRIORITY_HIGH);  data[0] = 0;       // TCP interface  data[1] = appcfgGetc(APPCFG_IP0);  data[2] = appcfgGetc(APPCFG_IP1);  data[3] = appcfgGetc(APPCFG_IP2);  data[4] = appcfgGetc(APPCFG_IP3);  vscp_transmit(mode, 5);}#endif  /* *///////////////////////////////////////////////////////////////////////////////// fillGUID//voidfillGUID(PVSCPEVENT pevent){  uint8_t i;  for (i = 0; i < 16; i++)    pevent->GUID[i] = vscp_getGUID(i);}